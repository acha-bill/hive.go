package identity

import (
	"crypto/rand"
	"crypto/sha256"
	"encoding/hex"
	"fmt"
	"strings"

	"github.com/iotaledger/hive.go/crypto/ed25519"
	"github.com/mr-tron/base58"
)

// IDLength contains the amount of bytes of the ID
const IDLength = sha256.Size

// ID is a unique identifier for each peer.
type ID [IDLength]byte

// NewID computes the ID corresponding to the given public key.
func NewID(key ed25519.PublicKey) ID {
	return sha256.Sum256(key.Bytes())
}

// Bytes returns the byte slice representation of the ID
func (id ID) Bytes() []byte {
	return id[:]
}

// String returns a shortened version of the ID as a base58 encoded string.
func (id ID) String() string {
	return base58.Encode(id[:8])
}

// ParseID parses a hex encoded ID.
func ParseID(s string) (ID, error) {
	var id ID
	b, err := hex.DecodeString(strings.TrimPrefix(s, "0x"))
	if err != nil {
		return id, err
	}
	if len(b) != len(ID{}) {
		return id, fmt.Errorf("invalid length: need %d hex chars", hex.EncodedLen(len(ID{})))
	}
	copy(id[:], b)
	return id, nil
}

// RandomID creates a random id which can for example be used in unit tests.
func RandomID() (id ID) {
	// generate a random sequence of bytes
	idBytes := make([]byte, IDLength)
	if _, err := rand.Read(idBytes); err != nil {
		panic(err)
	}

	// copy the generated bytes into the result
	copy(id[:], idBytes)

	return
}